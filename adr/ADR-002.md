Here is a new Architecture Decision Record (ADR) that documents the key technical decisions we implemented to make your ECS deployment stable, secure, and automated.

This ADR focuses on the *critical fixes* related to service startup, security, and networking that are essential for the system's health. You can add this as `ADR-002.md` to your repository.

---

# ADR-002: ECS Fargate Service Runtime, Security, and Health

**Status:** Accepted

**Date:** 2025-11-16

---

## Context

This project deploys a containerized Java/Spring Boot application on AWS ECS Fargate, fronted by an Application Load Balancer (ALB), and communicating with an SQS queue and an RDS database.

During initial deployment, the services (especially `service1`) failed to start, resulting in a cascade of `503`, `502`, and `400` errors. The root causes were related to (1) IAM permissions, (2) credential injection, (3) network security, and (4) application health check configurations. This ADR documents the decisions made to resolve these issues.

---

## Decision

We will implement a specific, multi-part configuration to ensure the ECS tasks are secure, can access required resources, and start up reliably.

### 1. Credential Management: Use Task Execution Role

The primary `ResourceInitializationError` was caused by the ECS agent failing to pull the database credentials from AWS Secrets Manager.

* **Decision:** We will add a dedicated IAM policy to the **Task Execution Role** (`ecs-task-execution-role`).
* **Rationale:** ECS uses two distinct roles. The **Task Role** (`task_role_arn`) is for the application code itself (e.g., writing to SQS). The **Task Execution Role** (`execution_role_arn`) is used by the ECS agent to perform actions *before* the container starts, such as pulling the ECR image and fetching secrets. This role *must* have `secretsmanager:GetSecretValue` permission on the database secret's ARN.
* **Implementation:** The credentials will be injected via the `secrets` block in the `aws_ecs_task_definition`, which maps the secret's keys (e.g., `username`, `password`) to environment variables.

### 2. Service Health: ALB Health Check Path & Grace Period

The `502` and `503` errors were caused by the ALB health checks failing.

* **Decision 1:** The `aws_lb_target_group` health check path will be changed from the default (`/`) to a valid application endpoint (`/jobs`).
* **Rationale 1:** The Spring Boot application does not have a handler for `/`, so the default health check would always fail. The `/jobs` endpoint is a lightweight, valid path that confirms the application is running.

* **Decision 2:** The `aws_ecs_service` resource will set a `health_check_grace_period_seconds` (e.g., 60 seconds).
* **Rationale 2:** Spring Boot applications can have a non-trivial startup time (10-30+ seconds) as they initialize the SQS client and database connections. Without a grace period, the ALB's health checks fail and terminate the task *before* it finishes starting.

### 3. Application Startup: SQS Client Permissions

Even with the correct health check path, the application failed to start because the Spring Boot SQS client requires permissions on initialization.

* **Decision:** The `service1_task_role` (the *application's* role) will be granted `sqs:GetQueueAttributes` in addition to `sqs:SendMessage`.
* **Rationale:** The `spring-cloud-aws-starter-sqs` library attempts to validate the queue connection on startup. This validation fails without `GetQueueAttributes`, which crashes the application, which in turn fails the health check.

### 4. Network Security: Specific Security Group Rules

The `502 Bad Gateway` error also indicated a networking-level failure.

* **Decision:** The `ecs-sg` (ECS service security group) will have its ingress rule changed from a broad "all ports" rule to a specific rule allowing `tcp` on port `8080` (the container's port) *only* from the `alb-sg` (ALB's security group).
* **Rationale:** Vague rules (like `from_port = 0`) are unreliable. A specific rule ensures the ALB can route traffic to the container port, while maintaining a secure "default-deny" posture for all other traffic.

### 5. Automation: Force Destroy S3 Bucket

The `terraform destroy` command failed because the `deployment.sh` script manually uploads `index.html` to the UI bucket, making it "not empty".

* **Decision:** The `aws_s3_bucket.ui_bucket` resource in `modules/frontend/main.tf` will have `force_destroy = true` set.
* **Rationale:** This allows Terraform to forcefully delete all objects in the bucket before deleting the bucket itself, enabling a clean, fully automated destroy process.

---

## Consequences

* **Positive:** The service is now stable, secure, and resilient. It can handle new deployments and restarts reliably. The IAM permissions are correctly separated between the ECS agent and the application. The deployment lifecycle (apply and destroy) is fully automated.
* **Negative/Trade-off:** The IAM configuration is now more complex, as developers must understand the difference between a Task Role and a Task Execution Role. The `health_check_grace_period` slightly increases the time it takes for a failing deployment to be rolled back.
